# Kçº¿æ ‡è®°åº“åŠŸèƒ½ç‰¹æ€§è¯¦è§£

## ğŸ“Š æ ‡è®°ç³»ç»Ÿæ·±å…¥è§£æ

### æ ‡è®°ç±»å‹ä¸è§†è§‰è®¾è®¡

#### 1. ä¹°å…¥æ ‡è®° (BUY)

- **ä½ç½®å®šä½**ï¼šKçº¿ä½ç‚¹ä¸‹æ–¹ï¼Œé¿å…é®æŒ¡ä»·æ ¼ä¿¡æ¯
- **è§†è§‰è®¾è®¡**ï¼šåœ†è§’çŸ©å½¢ï¼Œé»˜è®¤ç»¿è‰² (#4CAF50)
- **è¿æ¥çº¿**ï¼šè™šçº¿è¿æ¥åˆ°Kçº¿ä½ç‚¹ï¼Œå¢å¼ºå…³è”æ€§
- **æ–‡å­—æ˜¾ç¤º**ï¼šæ”¯æŒè‡ªå®šä¹‰æ–‡æœ¬ï¼Œé»˜è®¤"ä¹°å…¥"

#### 2. å–å‡ºæ ‡è®° (SELL)

- **ä½ç½®å®šä½**ï¼šKçº¿é«˜ç‚¹ä¸Šæ–¹ï¼Œæ¸…æ™°æ ‡è¯†å–å‡ºç‚¹
- **è§†è§‰è®¾è®¡**ï¼šåœ†è§’çŸ©å½¢ï¼Œé»˜è®¤çº¢è‰² (#F44336)
- **è¿æ¥çº¿**ï¼šè™šçº¿è¿æ¥åˆ°Kçº¿é«˜ç‚¹
- **æ–‡å­—æ˜¾ç¤º**ï¼šæ”¯æŒè‡ªå®šä¹‰æ–‡æœ¬ï¼Œé»˜è®¤"å–å‡º"

#### 3. æ•°å­—æ ‡è®° (NUMBER)

- **ä½ç½®å®šä½**ï¼šKçº¿ä¸­éƒ¨åä¾§ï¼Œä¸é®æŒ¡ä¸»è¦ä»·æ ¼åŒºåŸŸ
- **è§†è§‰è®¾è®¡**ï¼šåœ†å½¢èƒŒæ™¯ï¼ŒåŠé€æ˜ç°è‰²
- **å¼•å‡ºçº¿**ï¼šå›ºå®šé•¿åº¦å¼•å‡ºçº¿ï¼ŒæŒ‡å‘å¯¹åº”Kçº¿
- **æ–‡å­—æ˜¾ç¤º**ï¼šæ”¯æŒä»»æ„æ•°å­—æˆ–çŸ­æ–‡æœ¬

#### 4. ä¸‰è§’æ ‡è®° (TRIANGLE)

- **ä¸Šä¸‰è§’ (UP_TRIANGLE)**ï¼š
    - ä½ç½®ï¼šKçº¿ä½ç‚¹ä¸‹æ–¹
    - å½¢çŠ¶ï¼šç­‰è…°ä¸‰è§’å½¢ï¼Œé¡¶ç‚¹å‘ä¸Š
    - é¢œè‰²ï¼šæ©™è‰² (#FF5722)
    - å«ä¹‰ï¼šçœ‹æ¶¨ä¿¡å·

- **ä¸‹ä¸‰è§’ (DOWN_TRIANGLE)**ï¼š
    - ä½ç½®ï¼šKçº¿é«˜ç‚¹ä¸Šæ–¹
    - å½¢çŠ¶ï¼šç­‰è…°ä¸‰è§’å½¢ï¼Œé¡¶ç‚¹å‘ä¸‹
    - é¢œè‰²ï¼šç´«è‰² (#9C27B0)
    - å«ä¹‰ï¼šçœ‹è·Œä¿¡å·

### é«˜çº§é…ç½®é€‰é¡¹

```java
MarkerConfig config = new MarkerConfig.Builder()
    // åŸºæœ¬å°ºå¯¸é…ç½®
    .markerSize(14f)                    // æ ‡è®°å¤§å° (dp)
    .textSize(10f)                      // æ–‡å­—å¤§å° (sp)
    .cornerRadius(4f)                   // åœ†è§’åŠå¾„
    
    // é¢œè‰²é…ç½®
    .buyColor(Color.parseColor("#4CAF50"))
    .sellColor(Color.parseColor("#F44336"))
    .numberColor(Color.parseColor("#80BDBDBD"))
    .upTriangleColor(Color.parseColor("#FF5722"))
    .downTriangleColor(Color.parseColor("#9C27B0"))
    
    // è¿æ¥çº¿é…ç½®
    .fixedLineLength(25f)               // æ ‡å‡†è¿æ¥çº¿é•¿åº¦
    .shortLineLength(8f)                // çŸ­è¿æ¥çº¿é•¿åº¦
    .lineWidth(1.5f)                    // è¿æ¥çº¿å®½åº¦
    .dashPattern(new float[]{5f, 3f})   // è™šçº¿æ¨¡å¼
    
    // å®šä½é…ç½®
    .markerOffsetMultiplier(1.8f)       // æ ‡è®°åç§»å€æ•°
    .textPadding(6f)                    // æ–‡å­—å†…è¾¹è·
    .shadowRadius(2f)                   // é˜´å½±åŠå¾„
    .shadowOffset(1f)                   // é˜´å½±åç§»
    
    .build();
```

## ğŸ¨ è¶‹åŠ¿åŒºé—´ç³»ç»ŸæŠ€æœ¯å®ç°

### ç²¾è‡´é˜´å½±ç»˜åˆ¶ç®—æ³•

#### 1. è·¯å¾„æ„å»ºæŠ€æœ¯

```java
// æ ¸å¿ƒç®—æ³•ï¼šæ²¿Kçº¿èµ°åŠ¿ç»˜åˆ¶è‡ªç„¶é˜´å½±
private Path createTrendPath(List<PointF> trendPoints, float chartBottom) {
    Path path = new Path();
    
    // èµ·å§‹ç‚¹ï¼šä»å›¾è¡¨åº•éƒ¨å¼€å§‹
    path.moveTo(trendPoints.get(0).x, chartBottom);
    
    // æ²¿Kçº¿é«˜ç‚¹/ä½ç‚¹æ„å»ºä¸Šè¾¹ç•Œ
    for (int i = 0; i < trendPoints.size(); i++) {
        PointF point = trendPoints.get(i);
        
        if (i == 0) {
            path.lineTo(point.x, point.y);
        } else {
            // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿åˆ›å»ºå¹³æ»‘è¿æ¥
            PointF prevPoint = trendPoints.get(i - 1);
            float controlX = (prevPoint.x + point.x) / 2;
            float controlY = (prevPoint.y + point.y) / 2;
            path.quadTo(controlX, controlY, point.x, point.y);
        }
    }
    
    // å›åˆ°å›¾è¡¨åº•éƒ¨é—­åˆè·¯å¾„
    PointF lastPoint = trendPoints.get(trendPoints.size() - 1);
    path.lineTo(lastPoint.x, chartBottom);
    path.close();
    
    return path;
}
```

#### 2. ä¸‰è‰²æ¸å˜ç³»ç»Ÿ

```java
// ä¸Šæ¶¨è¶‹åŠ¿æ¸å˜ï¼šé€æ˜ â†’ å¾®ç»¿ â†’ è¾ƒæµ“ç»¿
LinearGradient risingGradient = new LinearGradient(
    0, topY, 0, bottomY,
    new int[]{
        Color.TRANSPARENT,                    // é¡¶éƒ¨ï¼šå®Œå…¨é€æ˜
        Color.parseColor("#1F4CAF50"),       // ä¸­éƒ¨ï¼š12%é€æ˜åº¦ç»¿è‰²
        Color.parseColor("#4F4CAF50")        // åº•éƒ¨ï¼š31%é€æ˜åº¦ç»¿è‰²
    },
    new float[]{0f, 0.5f, 1f},             // æ¸å˜ä½ç½®
    Shader.TileMode.CLAMP
);

// ä¸‹è·Œè¶‹åŠ¿æ¸å˜ï¼šè¾ƒæµ“çº¢ â†’ å¾®çº¢ â†’ é€æ˜  
LinearGradient fallingGradient = new LinearGradient(
    0, topY, 0, bottomY,
    new int[]{
        Color.parseColor("#4FF44336"),       // é¡¶éƒ¨ï¼š31%é€æ˜åº¦çº¢è‰²
        Color.parseColor("#1FF44336"),       // ä¸­éƒ¨ï¼š12%é€æ˜åº¦çº¢è‰²
        Color.TRANSPARENT                    // åº•éƒ¨ï¼šå®Œå…¨é€æ˜
    },
    new float[]{0f, 0.5f, 1f},
    Shader.TileMode.CLAMP
);
```

#### 3. æ™ºèƒ½è¾¹ç•Œè·Ÿè¸ª

- **ä¸Šæ¶¨è¶‹åŠ¿**ï¼šè·Ÿè¸ªKçº¿é«˜ç‚¹ï¼Œå½¢æˆä¸Šå‡è½¨è¿¹
- **ä¸‹è·Œè¶‹åŠ¿**ï¼šè·Ÿè¸ªKçº¿ä½ç‚¹ï¼Œå½¢æˆä¸‹é™è½¨è¿¹
- **æ™ºèƒ½åç§»**ï¼šå‘è¶‹åŠ¿æ–¹å‘åç§»10åƒç´ ï¼Œå¢å¼ºè§†è§‰æ•ˆæœ
- **è¾¹ç•Œçº¦æŸ**ï¼šè‡ªåŠ¨å¤„ç†å›¾è¡¨è¾¹ç•Œï¼Œé¿å…ç»˜åˆ¶è¶…å‡ºå¯è§†åŒºåŸŸ

### è¶‹åŠ¿æ£€æµ‹ç®—æ³•

#### è‡ªåŠ¨è¶‹åŠ¿è¯†åˆ«

```java
public class TrendDetector {
    private static final int MIN_TREND_LENGTH = 3;
    
    public List<TrendRegion> detectTrends(List<KLineEntry> klineData) {
        List<TrendRegion> trends = new ArrayList<>();
        
        int currentTrendStart = -1;
        TrendType currentTrendType = TrendType.NEUTRAL;
        int consecutiveCount = 0;
        
        for (int i = 1; i < klineData.size(); i++) {
            KLineEntry current = klineData.get(i);
            KLineEntry previous = klineData.get(i - 1);
            
            TrendType direction = determineTrendDirection(previous, current);
            
            if (direction == currentTrendType) {
                consecutiveCount++;
            } else {
                // è¶‹åŠ¿æ”¹å˜ï¼Œæ£€æŸ¥æ˜¯å¦å½¢æˆæœ‰æ•ˆè¶‹åŠ¿åŒºé—´
                if (consecutiveCount >= MIN_TREND_LENGTH && currentTrendStart >= 0) {
                    trends.add(createTrendRegion(
                        klineData, currentTrendStart, i - 1, currentTrendType
                    ));
                }
                
                // å¼€å§‹æ–°è¶‹åŠ¿
                currentTrendType = direction;
                currentTrendStart = i - 1;
                consecutiveCount = 1;
            }
        }
        
        // å¤„ç†æœ€åä¸€ä¸ªè¶‹åŠ¿åŒºé—´
        if (consecutiveCount >= MIN_TREND_LENGTH && currentTrendStart >= 0) {
            trends.add(createTrendRegion(
                klineData, currentTrendStart, klineData.size() - 1, currentTrendType
            ));
        }
        
        return trends;
    }
    
    private TrendType determineTrendDirection(KLineEntry prev, KLineEntry current) {
        if (current.close > prev.close) {
            return TrendType.RISING;
        } else if (current.close < prev.close) {
            return TrendType.FALLING;
        } else {
            return TrendType.NEUTRAL;
        }
    }
}
```

### JSONæ•°æ®æ ¼å¼æ”¯æŒ

#### æ ‡å‡†JSONç»“æ„

```json
{
  "items": [
    {
      "updated_at": "2024-05-22T07:09:33.289230Z",
      "start": "2024-05-15",
      "end": null,
      "size": 2,
      "type": "RISING",
      "confidence": 0.85,
      "metadata": {
        "detected_by": "auto",
        "peak_count": 3,
        "avg_volume": 1250.5
      }
    }
  ]
}
```

#### å­—æ®µè¯´æ˜

- **start**: è¶‹åŠ¿åŒºé—´èµ·å§‹æ—¥æœŸ (yyyy-MM-dd æ ¼å¼)
- **end**: è¶‹åŠ¿åŒºé—´ç»“æŸæ—¥æœŸï¼Œnullè¡¨ç¤ºå»¶ç»­åˆ°æœ€æ–°æ•°æ®
- **size**: è¶‹åŠ¿å¼ºåº¦çº§åˆ« (1-5)
- **type**: è¶‹åŠ¿ç±»å‹ ("RISING", "FALLING", "NEUTRAL")
- **confidence**: ç½®ä¿¡åº¦ (0.0-1.0)
- **metadata**: æ‰©å±•ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰

#### JSONè§£æå™¨

```java
public class TrendRegionParser {
    private final Gson gson = new Gson();
    
    public List<TrendRegion> parseFromJson(String jsonData) {
        try {
            TrendRegionResponse response = gson.fromJson(jsonData, TrendRegionResponse.class);
            List<TrendRegion> regions = new ArrayList<>();
            
            for (TrendRegionResponse.Item item : response.items) {
                TrendRegion region = new TrendRegion(
                    item.start,
                    item.end,
                    item.size,
                    item.updated_at,
                    TrendRegion.TrendType.valueOf(item.type)
                );
                
                // è®¾ç½®æ‰©å±•å±æ€§
                if (item.confidence != null) {
                    region.setConfidence(item.confidence);
                }
                
                regions.add(region);
            }
            
            return regions;
        } catch (Exception e) {
            Log.e("TrendRegionParser", "è§£æJSONå¤±è´¥", e);
            return new ArrayList<>();
        }
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### å¯è§†åŒºåŸŸå‰ªè£

```java
public class ViewportOptimizer {
    
    public List<MarkerData> getVisibleMarkers(
            List<MarkerData> allMarkers, 
            float visibleMinX, 
            float visibleMaxX) {
        
        return allMarkers.stream()
            .filter(marker -> {
                float markerX = dateToXValue(marker.getDate());
                return markerX >= visibleMinX && markerX <= visibleMaxX;
            })
            .collect(Collectors.toList());
    }
    
    public List<TrendRegion> getVisibleTrendRegions(
            List<TrendRegion> allRegions,
            float visibleMinX,
            float visibleMaxX) {
        
        return allRegions.stream()
            .filter(region -> {
                float startX = dateToXValue(region.getStartDate());
                float endX = region.getEndDate() != null ? 
                    dateToXValue(region.getEndDate()) : Float.MAX_VALUE;
                
                // åŒºé—´ä¸å¯è§†èŒƒå›´æœ‰äº¤é›†
                return !(endX < visibleMinX || startX > visibleMaxX);
            })
            .collect(Collectors.toList());
    }
}
```

### ç¼“å­˜æœºåˆ¶

```java
public class RenderCache {
    private Map<String, Path> pathCache = new ConcurrentHashMap<>();
    private Map<String, LinearGradient> gradientCache = new ConcurrentHashMap<>();
    
    public Path getCachedPath(String key, Supplier<Path> pathBuilder) {
        return pathCache.computeIfAbsent(key, k -> pathBuilder.get());
    }
    
    public LinearGradient getCachedGradient(String key, Supplier<LinearGradient> gradientBuilder) {
        return gradientCache.computeIfAbsent(key, k -> gradientBuilder.get());
    }
    
    public void clearCache() {
        pathCache.clear();
        gradientCache.clear();
    }
}
```

### å¼‚æ­¥æ•°æ®å¤„ç†

```java
public class AsyncTrendProcessor {
    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    
    public CompletableFuture<List<TrendRegion>> processJsonAsync(String jsonData) {
        return CompletableFuture.supplyAsync(() -> {
            // åœ¨åå°çº¿ç¨‹è§£æJSON
            return trendRegionParser.parseFromJson(jsonData);
        }, executor)
        .thenApply(regions -> {
            // åœ¨åå°çº¿ç¨‹è¿›è¡Œæ•°æ®é¢„å¤„ç†
            return preprocessTrendRegions(regions);
        });
    }
    
    private List<TrendRegion> preprocessTrendRegions(List<TrendRegion> regions) {
        // æ’åºã€å»é‡ã€éªŒè¯ç­‰é¢„å¤„ç†æ“ä½œ
        return regions.stream()
            .filter(this::validateTrendRegion)
            .sorted(Comparator.comparing(TrendRegion::getStartDate))
            .collect(Collectors.toList());
    }
}
```

## ğŸ”§ é«˜çº§è‡ªå®šä¹‰é€‰é¡¹

### è‡ªå®šä¹‰ç»˜åˆ¶å™¨

```java
public interface CustomMarkerRenderer {
    void drawMarker(Canvas canvas, MarkerData marker, float x, float y, Paint paint);
    RectF getMarkerBounds(MarkerData marker, float x, float y);
}

public class CustomTriangleRenderer implements CustomMarkerRenderer {
    @Override
    public void drawMarker(Canvas canvas, MarkerData marker, float x, float y, Paint paint) {
        Path trianglePath = new Path();
        float size = 10f;
        
        if (marker.getType() == MarkerData.MarkerType.UP_TRIANGLE) {
            trianglePath.moveTo(x, y - size);
            trianglePath.lineTo(x - size, y + size);
            trianglePath.lineTo(x + size, y + size);
        } else {
            trianglePath.moveTo(x, y + size);
            trianglePath.lineTo(x - size, y - size);
            trianglePath.lineTo(x + size, y - size);
        }
        trianglePath.close();
        
        canvas.drawPath(trianglePath, paint);
    }
}
```

### åŠ¨ç”»æ”¯æŒ

```java
public class MarkerAnimator {
    private ValueAnimator scaleAnimator;
    private ValueAnimator alphaAnimator;
    
    public void animateMarkerAppearance(MarkerData marker, AnimatorListener listener) {
        scaleAnimator = ValueAnimator.ofFloat(0f, 1f);
        scaleAnimator.setDuration(300);
        scaleAnimator.setInterpolator(new OvershootInterpolator());
        
        alphaAnimator = ValueAnimator.ofFloat(0f, 1f);
        alphaAnimator.setDuration(200);
        
        AnimatorSet animatorSet = new AnimatorSet();
        animatorSet.playTogether(scaleAnimator, alphaAnimator);
        animatorSet.addListener(listener);
        animatorSet.start();
    }
}
```

## ğŸ“ åæ ‡ç³»ç»Ÿè¯¦è§£

### Xè½´åæ ‡è½¬æ¢

```java
public class CoordinateTransformer {
    
    public float dateToXValue(Date date) {
        if (date == null) return 0;
        
        // æ–¹æ³•1ï¼šåŸºäºåŸºå‡†æ—¶é—´çš„å¤©æ•°åç§»
        long baseTime = 1704067200000L; // 2024-01-01 00:00:00 UTC
        long daysSinceBase = (date.getTime() - baseTime) / (24 * 60 * 60 * 1000);
        return (float) daysSinceBase;
    }
    
    public float indexToXValue(int index) {
        // æ–¹æ³•2ï¼šç›´æ¥ä½¿ç”¨æ•°æ®ç´¢å¼•
        return (float) index;
    }
    
    public Date xValueToDate(float xValue) {
        long baseTime = 1704067200000L;
        long timeStamp = baseTime + (long)(xValue * 24 * 60 * 60 * 1000);
        return new Date(timeStamp);
    }
}
```

### Yè½´å®šä½ç®—æ³•

```java
public class YPositionCalculator {
    
    public float calculateMarkerY(MarkerData marker, KLineEntry klineEntry, YAxis yAxis) {
        float high = klineEntry.getHigh();
        float low = klineEntry.getLow();
        
        switch (marker.getType()) {
            case BUY:
            case UP_TRIANGLE:
                // å®šä½åœ¨ä½ç‚¹ä¸‹æ–¹
                return yAxis.getPixelForValue(low) + getMarkerOffset();
                
            case SELL:
            case DOWN_TRIANGLE:
                // å®šä½åœ¨é«˜ç‚¹ä¸Šæ–¹
                return yAxis.getPixelForValue(high) - getMarkerOffset();
                
            case NUMBER:
            default:
                // å®šä½åœ¨ä¸­ç‚¹åå³
                float middle = (high + low) / 2;
                return yAxis.getPixelForValue(middle);
        }
    }
    
    private float getMarkerOffset() {
        return TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, 15f, 
            context.getResources().getDisplayMetrics()
        );
    }
}
```

è¿™ä¸ªåº“é€šè¿‡ç²¾å¿ƒè®¾è®¡çš„ç®—æ³•å’Œä¼˜åŒ–æŠ€æœ¯ï¼Œä¸ºMPAndroidChartæä¾›äº†ä¸“ä¸šçº§çš„æ ‡è®°å’Œè¶‹åŠ¿åŒºé—´åŠŸèƒ½ï¼ 