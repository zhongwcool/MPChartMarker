# K线标记库功能特性详解

## 📊 标记系统深入解析

### 标记类型与视觉设计

#### 1. 买入标记 (BUY)

- **位置定位**：K线低点下方，避免遮挡价格信息
- **视觉设计**：圆角矩形，默认绿色 (#4CAF50)
- **连接线**：虚线连接到K线低点，增强关联性
- **文字显示**：支持自定义文本，默认"买入"

#### 2. 卖出标记 (SELL)

- **位置定位**：K线高点上方，清晰标识卖出点
- **视觉设计**：圆角矩形，默认红色 (#F44336)
- **连接线**：虚线连接到K线高点
- **文字显示**：支持自定义文本，默认"卖出"

#### 3. 数字标记 (NUMBER)

- **位置定位**：K线中部偏侧，不遮挡主要价格区域
- **视觉设计**：圆形背景，半透明灰色
- **引出线**：固定长度引出线，指向对应K线
- **文字显示**：支持任意数字或短文本

#### 4. 三角标记 (TRIANGLE)

- **上三角 (UP_TRIANGLE)**：
    - 位置：K线低点下方
    - 形状：等腰三角形，顶点向上
    - 颜色：橙色 (#FF5722)
    - 含义：看涨信号

- **下三角 (DOWN_TRIANGLE)**：
    - 位置：K线高点上方
    - 形状：等腰三角形，顶点向下
    - 颜色：紫色 (#9C27B0)
    - 含义：看跌信号

### 高级配置选项

```java
MarkerConfig config = new MarkerConfig.Builder()
    // 基本尺寸配置
    .markerSize(14f)                    // 标记大小 (dp)
    .textSize(10f)                      // 文字大小 (sp)
    .cornerRadius(4f)                   // 圆角半径
    
    // 颜色配置
    .buyColor(Color.parseColor("#4CAF50"))
    .sellColor(Color.parseColor("#F44336"))
    .numberColor(Color.parseColor("#80BDBDBD"))
    .upTriangleColor(Color.parseColor("#FF5722"))
    .downTriangleColor(Color.parseColor("#9C27B0"))
    
    // 连接线配置
    .fixedLineLength(25f)               // 标准连接线长度
    .shortLineLength(8f)                // 短连接线长度
    .lineWidth(1.5f)                    // 连接线宽度
    .dashPattern(new float[]{5f, 3f})   // 虚线模式
    
    // 定位配置
    .markerOffsetMultiplier(1.8f)       // 标记偏移倍数
    .textPadding(6f)                    // 文字内边距
    .shadowRadius(2f)                   // 阴影半径
    .shadowOffset(1f)                   // 阴影偏移
    
    .build();
```

## 🎨 趋势区间系统技术实现

### 精致阴影绘制算法

#### 1. 路径构建技术

```java
// 核心算法：沿K线走势绘制自然阴影
private Path createTrendPath(List<PointF> trendPoints, float chartBottom) {
    Path path = new Path();
    
    // 起始点：从图表底部开始
    path.moveTo(trendPoints.get(0).x, chartBottom);
    
    // 沿K线高点/低点构建上边界
    for (int i = 0; i < trendPoints.size(); i++) {
        PointF point = trendPoints.get(i);
        
        if (i == 0) {
            path.lineTo(point.x, point.y);
        } else {
            // 使用二次贝塞尔曲线创建平滑连接
            PointF prevPoint = trendPoints.get(i - 1);
            float controlX = (prevPoint.x + point.x) / 2;
            float controlY = (prevPoint.y + point.y) / 2;
            path.quadTo(controlX, controlY, point.x, point.y);
        }
    }
    
    // 回到图表底部闭合路径
    PointF lastPoint = trendPoints.get(trendPoints.size() - 1);
    path.lineTo(lastPoint.x, chartBottom);
    path.close();
    
    return path;
}
```

#### 2. 三色渐变系统

```java
// 上涨趋势渐变：透明 → 微绿 → 较浓绿
LinearGradient risingGradient = new LinearGradient(
    0, topY, 0, bottomY,
    new int[]{
        Color.TRANSPARENT,                    // 顶部：完全透明
        Color.parseColor("#1F4CAF50"),       // 中部：12%透明度绿色
        Color.parseColor("#4F4CAF50")        // 底部：31%透明度绿色
    },
    new float[]{0f, 0.5f, 1f},             // 渐变位置
    Shader.TileMode.CLAMP
);

// 下跌趋势渐变：较浓红 → 微红 → 透明  
LinearGradient fallingGradient = new LinearGradient(
    0, topY, 0, bottomY,
    new int[]{
        Color.parseColor("#4FF44336"),       // 顶部：31%透明度红色
        Color.parseColor("#1FF44336"),       // 中部：12%透明度红色
        Color.TRANSPARENT                    // 底部：完全透明
    },
    new float[]{0f, 0.5f, 1f},
    Shader.TileMode.CLAMP
);
```

#### 3. 智能边界跟踪

- **上涨趋势**：跟踪K线高点，形成上升轨迹
- **下跌趋势**：跟踪K线低点，形成下降轨迹
- **智能偏移**：向趋势方向偏移10像素，增强视觉效果
- **边界约束**：自动处理图表边界，避免绘制超出可视区域

### 趋势检测算法

#### 自动趋势识别

```java
public class TrendDetector {
    private static final int MIN_TREND_LENGTH = 3;
    
    public List<TrendRegion> detectTrends(List<KLineEntry> klineData) {
        List<TrendRegion> trends = new ArrayList<>();
        
        int currentTrendStart = -1;
        TrendType currentTrendType = TrendType.NEUTRAL;
        int consecutiveCount = 0;
        
        for (int i = 1; i < klineData.size(); i++) {
            KLineEntry current = klineData.get(i);
            KLineEntry previous = klineData.get(i - 1);
            
            TrendType direction = determineTrendDirection(previous, current);
            
            if (direction == currentTrendType) {
                consecutiveCount++;
            } else {
                // 趋势改变，检查是否形成有效趋势区间
                if (consecutiveCount >= MIN_TREND_LENGTH && currentTrendStart >= 0) {
                    trends.add(createTrendRegion(
                        klineData, currentTrendStart, i - 1, currentTrendType
                    ));
                }
                
                // 开始新趋势
                currentTrendType = direction;
                currentTrendStart = i - 1;
                consecutiveCount = 1;
            }
        }
        
        // 处理最后一个趋势区间
        if (consecutiveCount >= MIN_TREND_LENGTH && currentTrendStart >= 0) {
            trends.add(createTrendRegion(
                klineData, currentTrendStart, klineData.size() - 1, currentTrendType
            ));
        }
        
        return trends;
    }
    
    private TrendType determineTrendDirection(KLineEntry prev, KLineEntry current) {
        if (current.close > prev.close) {
            return TrendType.RISING;
        } else if (current.close < prev.close) {
            return TrendType.FALLING;
        } else {
            return TrendType.NEUTRAL;
        }
    }
}
```

### JSON数据格式支持

#### 标准JSON结构

```json
{
  "items": [
    {
      "updated_at": "2024-05-22T07:09:33.289230Z",
      "start": "2024-05-15",
      "end": null,
      "size": 2,
      "type": "RISING",
      "confidence": 0.85,
      "metadata": {
        "detected_by": "auto",
        "peak_count": 3,
        "avg_volume": 1250.5
      }
    }
  ]
}
```

#### 字段说明

- **start**: 趋势区间起始日期 (yyyy-MM-dd 格式)
- **end**: 趋势区间结束日期，null表示延续到最新数据
- **size**: 趋势强度级别 (1-5)
- **type**: 趋势类型 ("RISING", "FALLING", "NEUTRAL")
- **confidence**: 置信度 (0.0-1.0)
- **metadata**: 扩展信息（可选）

#### JSON解析器

```java
public class TrendRegionParser {
    private final Gson gson = new Gson();
    
    public List<TrendRegion> parseFromJson(String jsonData) {
        try {
            TrendRegionResponse response = gson.fromJson(jsonData, TrendRegionResponse.class);
            List<TrendRegion> regions = new ArrayList<>();
            
            for (TrendRegionResponse.Item item : response.items) {
                TrendRegion region = new TrendRegion(
                    item.start,
                    item.end,
                    item.size,
                    item.updated_at,
                    TrendRegion.TrendType.valueOf(item.type)
                );
                
                // 设置扩展属性
                if (item.confidence != null) {
                    region.setConfidence(item.confidence);
                }
                
                regions.add(region);
            }
            
            return regions;
        } catch (Exception e) {
            Log.e("TrendRegionParser", "解析JSON失败", e);
            return new ArrayList<>();
        }
    }
}
```

## ⚡ 性能优化技术

### 可视区域剪裁

```java
public class ViewportOptimizer {
    
    public List<MarkerData> getVisibleMarkers(
            List<MarkerData> allMarkers, 
            float visibleMinX, 
            float visibleMaxX) {
        
        return allMarkers.stream()
            .filter(marker -> {
                float markerX = dateToXValue(marker.getDate());
                return markerX >= visibleMinX && markerX <= visibleMaxX;
            })
            .collect(Collectors.toList());
    }
    
    public List<TrendRegion> getVisibleTrendRegions(
            List<TrendRegion> allRegions,
            float visibleMinX,
            float visibleMaxX) {
        
        return allRegions.stream()
            .filter(region -> {
                float startX = dateToXValue(region.getStartDate());
                float endX = region.getEndDate() != null ? 
                    dateToXValue(region.getEndDate()) : Float.MAX_VALUE;
                
                // 区间与可视范围有交集
                return !(endX < visibleMinX || startX > visibleMaxX);
            })
            .collect(Collectors.toList());
    }
}
```

### 缓存机制

```java
public class RenderCache {
    private Map<String, Path> pathCache = new ConcurrentHashMap<>();
    private Map<String, LinearGradient> gradientCache = new ConcurrentHashMap<>();
    
    public Path getCachedPath(String key, Supplier<Path> pathBuilder) {
        return pathCache.computeIfAbsent(key, k -> pathBuilder.get());
    }
    
    public LinearGradient getCachedGradient(String key, Supplier<LinearGradient> gradientBuilder) {
        return gradientCache.computeIfAbsent(key, k -> gradientBuilder.get());
    }
    
    public void clearCache() {
        pathCache.clear();
        gradientCache.clear();
    }
}
```

### 异步数据处理

```java
public class AsyncTrendProcessor {
    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    
    public CompletableFuture<List<TrendRegion>> processJsonAsync(String jsonData) {
        return CompletableFuture.supplyAsync(() -> {
            // 在后台线程解析JSON
            return trendRegionParser.parseFromJson(jsonData);
        }, executor)
        .thenApply(regions -> {
            // 在后台线程进行数据预处理
            return preprocessTrendRegions(regions);
        });
    }
    
    private List<TrendRegion> preprocessTrendRegions(List<TrendRegion> regions) {
        // 排序、去重、验证等预处理操作
        return regions.stream()
            .filter(this::validateTrendRegion)
            .sorted(Comparator.comparing(TrendRegion::getStartDate))
            .collect(Collectors.toList());
    }
}
```

## 🔧 高级自定义选项

### 自定义绘制器

```java
public interface CustomMarkerRenderer {
    void drawMarker(Canvas canvas, MarkerData marker, float x, float y, Paint paint);
    RectF getMarkerBounds(MarkerData marker, float x, float y);
}

public class CustomTriangleRenderer implements CustomMarkerRenderer {
    @Override
    public void drawMarker(Canvas canvas, MarkerData marker, float x, float y, Paint paint) {
        Path trianglePath = new Path();
        float size = 10f;
        
        if (marker.getType() == MarkerData.MarkerType.UP_TRIANGLE) {
            trianglePath.moveTo(x, y - size);
            trianglePath.lineTo(x - size, y + size);
            trianglePath.lineTo(x + size, y + size);
        } else {
            trianglePath.moveTo(x, y + size);
            trianglePath.lineTo(x - size, y - size);
            trianglePath.lineTo(x + size, y - size);
        }
        trianglePath.close();
        
        canvas.drawPath(trianglePath, paint);
    }
}
```

### 动画支持

```java
public class MarkerAnimator {
    private ValueAnimator scaleAnimator;
    private ValueAnimator alphaAnimator;
    
    public void animateMarkerAppearance(MarkerData marker, AnimatorListener listener) {
        scaleAnimator = ValueAnimator.ofFloat(0f, 1f);
        scaleAnimator.setDuration(300);
        scaleAnimator.setInterpolator(new OvershootInterpolator());
        
        alphaAnimator = ValueAnimator.ofFloat(0f, 1f);
        alphaAnimator.setDuration(200);
        
        AnimatorSet animatorSet = new AnimatorSet();
        animatorSet.playTogether(scaleAnimator, alphaAnimator);
        animatorSet.addListener(listener);
        animatorSet.start();
    }
}
```

## 📐 坐标系统详解

### X轴坐标转换

```java
public class CoordinateTransformer {
    
    public float dateToXValue(Date date) {
        if (date == null) return 0;
        
        // 方法1：基于基准时间的天数偏移
        long baseTime = 1704067200000L; // 2024-01-01 00:00:00 UTC
        long daysSinceBase = (date.getTime() - baseTime) / (24 * 60 * 60 * 1000);
        return (float) daysSinceBase;
    }
    
    public float indexToXValue(int index) {
        // 方法2：直接使用数据索引
        return (float) index;
    }
    
    public Date xValueToDate(float xValue) {
        long baseTime = 1704067200000L;
        long timeStamp = baseTime + (long)(xValue * 24 * 60 * 60 * 1000);
        return new Date(timeStamp);
    }
}
```

### Y轴定位算法

```java
public class YPositionCalculator {
    
    public float calculateMarkerY(MarkerData marker, KLineEntry klineEntry, YAxis yAxis) {
        float high = klineEntry.getHigh();
        float low = klineEntry.getLow();
        
        switch (marker.getType()) {
            case BUY:
            case UP_TRIANGLE:
                // 定位在低点下方
                return yAxis.getPixelForValue(low) + getMarkerOffset();
                
            case SELL:
            case DOWN_TRIANGLE:
                // 定位在高点上方
                return yAxis.getPixelForValue(high) - getMarkerOffset();
                
            case NUMBER:
            default:
                // 定位在中点偏右
                float middle = (high + low) / 2;
                return yAxis.getPixelForValue(middle);
        }
    }
    
    private float getMarkerOffset() {
        return TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, 15f, 
            context.getResources().getDisplayMetrics()
        );
    }
}
```

这个库通过精心设计的算法和优化技术，为MPAndroidChart提供了专业级的标记和趋势区间功能！ 